use axum::{
    extract::{State, Json},
    routing::{get, post},
    Router,
    response::IntoResponse,
    http::StatusCode,
};
use std::sync::{Arc, Mutex};
use tower_http::services::ServeDir;
use tower_http::cors::CorsLayer;
use serde::Deserialize;
use shadcn_feed_reader::shared::{
    ProxyState, LoginRequest,
    logic_fetch_article, logic_fetch_raw_html, logic_perform_form_login
};
use shadcn_feed_reader::proxy;

#[derive(Clone)]
struct AppState {
    proxy_state: ProxyState,
}

// Handler request types
#[derive(Deserialize)]
struct UrlPayload {
    url: String,
}

#[derive(Deserialize)]
struct AuthPayload {
    domain: String,
    username: String,
    password: String,
}

#[derive(Deserialize)]
struct DomainPayload {
    domain: String,
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();

    let proxy_state = ProxyState::default();
    
    // Enable relative paths for the proxy since we serve it on the same origin
    {
        let mut relative_guard = proxy_state.use_relative_paths.lock().unwrap();
        *relative_guard = true;
    }
    
    // Note: We do NOT spawn a separate proxy server here.
    // Instead, we integrate the proxy logic directly into the main router.

    let app_state = AppState {
        proxy_state,
    };

    let api_routes = Router::new()
        .route("/fetch_article", post(api_fetch_article))
        .route("/fetch_raw_html", post(api_fetch_raw_html))
        .route("/perform_form_login", post(api_perform_form_login))
        .route("/set_proxy_auth", post(api_set_proxy_auth))
        .route("/clear_proxy_auth", post(api_clear_proxy_auth))
        .route("/start_proxy", post(api_start_proxy))
        .route("/set_proxy_url", post(api_set_proxy_url))
        .with_state(app_state.clone());

    let app = Router::new()
        .nest("/api", api_routes)
        // Mount the proxy resource handler directly
        // This handles /proxy?url=... requests generated by the HTML rewriter
        .route("/proxy", get(proxy::proxy_resource_handler).options(proxy::cors_options_handler))
        .with_state(app_state.proxy_state.clone())
        // Serve frontend static files
        .fallback_service(ServeDir::new("dist").fallback(ServeDir::new("dist/index.html")))
        .layer(CorsLayer::permissive());

    let port = std::env::var("PORT").unwrap_or_else(|_| "3000".to_string());
    let addr = format!("0.0.0.0:{}", port);
    println!("Web server listening on {}", addr);

    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    axum::serve(listener, app).await.unwrap();
}

async fn api_fetch_article(
    Json(payload): Json<UrlPayload>,
) -> impl IntoResponse {
    match logic_fetch_article(payload.url).await {
        Ok(content) => (StatusCode::OK, content),
        Err(e) => (StatusCode::INTERNAL_SERVER_ERROR, e),
    }
}

async fn api_fetch_raw_html(
    State(state): State<AppState>,
    Json(payload): Json<UrlPayload>,
) -> impl IntoResponse {
    match logic_fetch_raw_html(payload.url, &state.proxy_state).await {
        Ok(content) => (StatusCode::OK, content),
        Err(e) => (StatusCode::INTERNAL_SERVER_ERROR, e),
    }
}

async fn api_perform_form_login(
    State(state): State<AppState>,
    Json(payload): Json<LoginRequest>,
) -> impl IntoResponse {
    match logic_perform_form_login(payload, &state.proxy_state).await {
        Ok(response) => (StatusCode::OK, Json(response)).into_response(),
        Err(e) => (StatusCode::INTERNAL_SERVER_ERROR, e).into_response(),
    }
}

async fn api_set_proxy_auth(
    State(state): State<AppState>,
    Json(payload): Json<AuthPayload>,
) -> impl IntoResponse {
    let mut credentials = state.proxy_state.auth_credentials.lock().unwrap();
    credentials.insert(payload.domain.clone(), (payload.username, payload.password));
    println!("Set auth credentials for domain: {}", payload.domain);
    StatusCode::OK
}

async fn api_clear_proxy_auth(
    State(state): State<AppState>,
    Json(payload): Json<DomainPayload>,
) -> impl IntoResponse {
    let mut credentials = state.proxy_state.auth_credentials.lock().unwrap();
    credentials.remove(&payload.domain);
    println!("Cleared auth credentials for domain: {}", payload.domain);
    StatusCode::OK
}

async fn api_start_proxy(
    State(state): State<AppState>,
) -> impl IntoResponse {
    // Return the port if already running
    let port_guard = state.proxy_state.port.lock().unwrap();
    if let Some(port) = *port_guard {
        return (StatusCode::OK, port.to_string());
    }
    // Should depend on the auto-start logic, but for now we assume it started
    (StatusCode::OK, "0".to_string())
}

async fn api_set_proxy_url(
    State(state): State<AppState>,
    Json(payload): Json<UrlPayload>,
) -> impl IntoResponse {
    if let Ok(new_url) = url::Url::parse(&payload.url) {
        let mut base_url = state.proxy_state.base_url.lock().unwrap();
        *base_url = new_url;
        StatusCode::OK
    } else {
        StatusCode::BAD_REQUEST
    }
}
